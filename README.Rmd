---
output:
  md_document:
    variant: markdown_github
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-",
  dpi = 250
)
```

# mpoly

## Specifying polynomials

__mpoly__ is a simple collection of tools to help deal with multivariate polynomials _symbolically_ and functionally in R.  Polynomials are defined with the `mp()` function:

```{r mp, echo = TRUE}
library(mpoly)
mp("x + y")
mp("(x + 4y)^2 (x - .25)")
```

[Term orders](http://en.wikipedia.org/wiki/Lexicographical_order#Monomials) are available with the reorder function:
```{r}
(p <- mp("(x + y)^2 (1 + x)"))
reorder(p, varorder = c('y','x'), order = 'lex')
reorder(p, varorder = c('x','y'), order = 'glex')
```

Vectors of polynomials (`mpolyList`'s) can be specified in the same way:
```{r}
mp(c("(x+y)^2", "z"))
```

## Polynomial arithmetic

Arithmetic is defined for both polynomials (`+`, `-`, `*` and `^`)...
```{r}
p1 <- mp("x + y")
p2 <- mp("x - y")

p1 + p2
p1 - p2
p1 * p2
p1^2
```

... and vectors of polynomials:
```{r}
(ps1 <- mp(c("x", "y")))
(ps2 <- mp(c("2x", "y+z")))
ps1 + ps2
ps1 - ps2
ps1 * ps2
```


## Some calculus

You can compute derivatives easily:
```{r}
p <- mp("x + x y + x y^2")
deriv(p, "y")
gradient(p)
```


## Function coercion

You can turn polynomials and vectors of polynomials into functions you can evaluate with `as.function()`.  For example, you can visualize a univariate polynomials like this:
```{r, fig.height=3}
f <- as.function(mp("(x-2) x (x+2)"))
s <- seq(-2.5, 2.5, .1)
df <- expand.grid(x = s)
df$f <- apply(df, 1, f)

library(ggplot2); theme_set(theme_bw())
qplot(x, f, data = df, geom = "line")
```


Or a bivariate polynomial like this:
```{r}
f <- as.function(mp("x^2 - y^2")) 
df <- expand.grid(x = s, y = s)
df$f <- apply(df, 1, f)
qplot(x, y, data = df, geom = "tile", fill = f)
```

## Algebraic geometry

Grobner bases computations are available using __rSymPy__:

```{r}
polys <- mp(c("t^4 - x", "t^3 - y", "t^2 - z"))
grobner(polys)
```


## Special polynomials

You can construct [Chebyshev polynomials](http://en.wikipedia.org/wiki/Chebyshev_polynomials) as follows:
```{r}
chebyshev(1)
chebyshev(2)
chebyshev(0:5)
```

And you can visualize them:
```{r, fig.height=3}
library(reshape2)

s <- seq(-1, 1, length.out = 201)
N <- 5 # number of chebyshev polynomials to plot
(chebPolys <- chebyshev(0:N))

df <- t(sapply(s, as.function(chebPolys)) )
df <- as.data.frame(cbind(s, df))
names(df) <- c("x", paste0("T_", 0:N))
mdf <- melt(df, id = "x")
qplot(x, value, data = mdf, geom = "line", color = variable)
```

[Bernstein polynomials](http://en.wikipedia.org/wiki/Bernstein_polynomial) are available with `bernstein()`:
```{r, fig.height=3}
bernstein(0:4, 4)

s <- seq(0, 1, length.out = 101)
N <- 5 # number of bernstein polynomials to plot
(bernPolys <- bernstein(0:N, N))

df <- t(sapply(s, as.function(bernPolys)) )
df <- as.data.frame(cbind(s, df))
names(df) <- c("x", paste0("B_", 0:N))
mdf <- melt(df, id = "x")
qplot(x, value, data = mdf, geom = "line", color = variable)
```

You can use the `bernsteinApprox()` function to compute the Bernstein polynomial approximation to a function.  Here's an approximation to the standard normal density:

```{r, fig.height=3}
p <- bernsteinApprox(dnorm, 15, -1.25, 1.25)
round(p, 4)

x <- seq(-3, 3, length.out = 101)
df <- data.frame(
  x = rep(x, 2),
  y = c(dnorm(x), as.function(p)(x)),
  which = rep(c("actual", "approx"), each = 101)
)
qplot(x, y, data = df, geom = "line", color = which)
```



## Bezier polynomials and curves

You can construct [Bezier polynomials](http://en.wikipedia.org/wiki/BÃ©zier_curve) for a given collection of points with `bezier()`:
```{r, fig.height=3}
points <- data.frame(x = c(-1,-2,2,1), y = c(0,1,1,0))
(bezPolys <- bezier(points))
```

And viewing them is just as easy:
```{r, fig.height = 3}
df <- t(sapply(s, as.function(bezPolys)) )
df <- as.data.frame(df)
names(df) <- c("x", "y")
qplot(x, y, data = df, geom = "path") +
  geom_path(data = points, color = "red") +
  geom_point(data = points, color = "red", size = 4)
```



## Other stuff

I'm starting to put in methods for some other R functions:

```{r, fig.height=3}
n <- 101
df <- data.frame(x = seq(-5, 5, length.out = n))
df$y <- with(df, -x^2 + 2*x - 3 + rnorm(n, 0, 2))

mod <- lm(y ~ x + I(x^2), data = df)
(p <- round(as.mpoly(mod)))
qplot(x, y, data = df) +
  stat_function(fun = as.function(p), colour = 'red')
```



## Installation

* From CRAN: `install.packages("mpoly")`

* From Github (dev version): 
```R
# install.packages("devtools")
devtools::install_github("Rexamine/stringi")
devtools::install_github("hadley/stringr")
devtools::install_github("dkahle/mpoly")
```



